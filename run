#!/usr/bin/env python3

import json
import os
import os.path
import argparse
import subprocess
import random
import string
import textwrap

PROJECT_NAME = 'tkfw2'
DEFAULT_PORT = 8000
BUILD_PATH = 'build'

def main():
  proj_dir = os.path.abspath(os.path.dirname(os.path.abspath(__file__)))

  parser = argparse.ArgumentParser(description='run or deploy the application')

  parser.add_argument('config', type=str,
                      help='config filename')
  parser.add_argument('command', type=str,
                      help='command to run -- can be: fg, bg, stop, deploy, cli')

  args = parser.parse_args()

  with open(args.config) as config_f:
    config = json.load(config_f)

  os.chdir(proj_dir)

  if not os.path.exists(BUILD_PATH):
    os.mkdir(BUILD_PATH)

  parse_config(config)

  config_nginx()

  if args.command == 'fg':
    docker_build()
    subprocess.call(['docker-compose', 'up'])

  if args.command == 'cli':
    docker_build()
    subprocess.call(['docker-compose', 'run', 'server', 'node'])

def docker_build():
  subprocess.call(['docker-compose', 'down'])
  subprocess.call(['docker-compose', 'build'])

def parse_config(config):
  global use_ssl, local, port, develop, admin_password

  domain = config.get('domain')
  if domain:
    use_ssl = True
  else:
    use_ssl = False
    local = config.get('local', True)
    port = config.get('port', DEFAULT_PORT)
  develop = config.get('develop', False)
  admin_password = config.get('admin_password')
  if admin_password is None:
    admin_password = random_password()
    print(f'admin_password - randomly generated for this build: {admin_password}')
  assert admin_password

def random_password():
  rand = random.SystemRandom()
  chars = string.ascii_lowercase + string.ascii_uppercase + string.digits
  return ''.join(random.choice(chars) for _ in range(32))

def config_nginx():
  app_part = textwrap.dedent(f'''
    client_max_body_size 500M;
    gzip on;
    gzip_vary on;
    gzip_min_length 10240;
    gzip_proxied expired no-cache no-store private auth;
    gzip_types text/plain text/css text/xml text/javascript application/javascript application/x-javascript application/xml;
    proxy_connect_timeout       300;
    proxy_send_timeout          300;
    proxy_read_timeout          300;
    send_timeout                300;

    location / {{
      proxy_pass http://client:8082/;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_redirect off;
    }}

    location /express/ {{
      proxy_pass http://server:8080/;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_redirect off;
    }}

    location /mongo-express/ {{
      proxy_pass http://mongo-express:8081/mongo-express/;

      auth_basic "";
      auth_basic_user_file /opt/htpasswd-admin;

      proxy_http_version 1.1;
      proxy_set_header Upgrade $http_upgrade;
      proxy_set_header Connection "upgrade";

      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header X-Forwarded-Proto $scheme;

      proxy_buffering off;
      proxy_redirect off;
    }}
  ''')

  if use_ssl:
    nginx_config = textwrap.dedent(f'''
      server {{
        server_name {domain};

        listen 80;
        listen [::]:80;

        return 301 https://{domain}$request_uri;
      }}

      server {{
        server_name {domain};

        listen 443 ssl http2;
        listen [::]:443 ssl http2;

        {app_part}

        ssl_certificate /etc/letsencrypt/live/{domain}/fullchain.pem;
        ssl_certificate_key /etc/letsencrypt/live/{domain}/privkey.pem;
      }}
    ''')
  elif local:
    nginx_config = textwrap.dedent(f'''
      server {{
        server_name app;

        listen {port};
        listen [::]:{port};

        {app_part}
      }}
    ''')
  else: # not use_ssl; not local
    nginx_config = textwrap.dedent(f'''
      server {{
        server_name app;

        listen 127.0.0.1:{port};

        {app_part}
      }}
    ''')

  with open(os.path.join('build', 'nginx_app.conf'), 'w') as f:
    f.write(nginx_config)


  # Below doesn't work because env vars aren't accessible at build-time, but this code may be useful for future dynamic env vars
  # nginx_env = textwrap.dedent(f'''
  #   ADMIN_PASSWORD={admin_password}
  # ''')
  # with open(os.path.join('build', 'nginx.env'), 'w') as f:
  #   f.write(nginx_env)

  with open(os.path.join('build', 'nginx_admin_password.txt'), 'w') as f:
    f.write(admin_password)


if __name__ == '__main__':
  main()
